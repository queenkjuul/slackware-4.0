
                              Linux & AI/Alife
                                 mini-HOWTO
                                      
                                Version 2.0
                                      
            This document is maintained by [1]John A. Eikenberry
                    The master page for this document is
                   [2]http://www.ai.uga.edu/~jae/ai.html
                Last modified: Tue Jan 13 17:23:21 EST 1998
     _________________________________________________________________
   
Table of Contents

     [3]What's New
     [4]Introduction
          + [5]Purpose
          + [6]Finding the Software
          + [7]Updates and Comments
     [8]Programming Languages
     [9]Traditional Artificial Intelligence
          + [10]AI class/code libraries
          + [11]AI software kits, applications, etc.
     [12]Connectionism (neural nets)
          + [13]Connectionist Class/Code Libraries
          + [14]Connectionist Applications
     [15]Evolutionary Computing (EC) (genetic algorithms/programming)
          + [16]EC Class/Code Libraries
          + [17]EC Applications
     [18]Artificial Life
          + [19]Alife class/code libraries
          + [20]Alife software kits, applications, etc.
     [21]Autonomous Agents and Bots
     [22]AI & Alife related newsgroups
     [23]AI & Alife resource links
     _________________________________________________________________
   
What's New

   Note: For a list of new additions to this mini-howto, please visit the
   [24]master page listed above.
   
   (1.11.98)Thanks to [25]Dirk Heise for his submission of Gas. I've also
   removed a couple more of the non-AI oriented scheme implementations. I
   just felt having 10 scheme implementations listed was a bit silly,
   especially since some of them weren't really meant for AI stuff. If
   you want a listing of more scheme's look [26]here or [27]here.
   
   (12.29.97) Added a couple more entries and web links, including a
   patched lil-gp.
   
   (10.1.97) Ok. I struck the motherload of Baysean Networks, see the
   Connectionism section for more. Plus I cleaned off the 'New' flags
   from anything before August.
   
   (9.26.97) The reformat is done! :) If you are reading this somewhere
   other than the master page, please [28]take a look and [29]let me know
   what you think. Now I can get back to work on my thesis...
   
Purpose

   The Linux OS has evolved from its origins in hackerdom to a full blown
   UNIX, capable of rivaling any commercial UNIX. It now provides an
   inexpensive base to build a great workstation. It has shed its
   hardware dependencies, having been ported to DEC Alphas, Sparcs,
   PowerPCs, with others on the way. This potential speed boost along
   with its networking support will make it great for workstation
   clusters. As a workstation it allows for all sorts of research and
   development, including artificial intelligence and artificial life.
   
   The purpose of this Mini-Howto is to provide a source to find out
   about various software packages, code libraries, and anything else
   that will help someone get started working with (and find resources
   for) artificial intelligence and artificial life. All done with Linux
   specifically in mind.
   
Where to find this software

   All this software should be available via the net (ftp || http). The
   links to where to find it will be provided in the description of each
   package. There will also be plenty of software not covered on these
   pages (which is usually platform independent) located on one of the
   resources listed under the [30]Web Links section.
   
Updates and comments

   If you find any mistakes, know of updates to one of the items below,
   or have problems compiling and of the applications, please mail me at:
   [31]jae@ai.uga.edu and I'll see what I can do.
   
   If you know of any AI/Alife applications, class libraries, etc. Please
   [32]email me about them. Include your name, ftp and/or http sites
   where they can be found, plus a brief overview/commentary on the
   software (this info would make things a lot easier on me... but don't
   feel obligated ;).
   
   I know that keeping this list up to date and expanding it will take
   quite a bit of work. So please be patient (I do have other projects).
   I hope you will find this document helpful.
     _________________________________________________________________
   
Programming languages

   While any programming language can be used for artificial
   intelligence/life research, these are programming languages which are
   used extensively for, if not specifically made for, artificial
   intelligence programming.
   
   ECoLisp [New]
          Web site: [33]www.di.unipi.it/~attardi/software.html
          ECoLisp (Embeddable Common Lisp) is an implementation of Common
          Lisp designed for being embeddable into C based applications.
          ECL uses standard C calling conventions for Lisp compiled
          functions, which allows C programs to easily call Lisp
          functions and viceversa. No foreign function interface is
          required: data can be exchanged between C and Lisp with no need
          for conversion. ECL is based on a Common Runtime Support (CRS)
          which provides basic facilities for memory managment, dynamic
          loading and dumping of binary images, support for multiple
          threads of execution. The CRS is built into a library that can
          be linked with the code of the application. ECL is modular:
          main modules are the program development tools (top level,
          debugger, trace, stepper), the compiler, and CLOS. A native
          implementation of CLOS is available in ECL: one can configure
          ECL with or without CLOS. A runtime version of ECL can be built
          with just the modules which are required by the application.
          The ECL compiler compiles from Lisp to C, and then invokes the
          GCC compiler to produce binaries.
          
   Gödel
          Web page: [34]www.cs.bris.ac.uk/~bowers/goedel.html
          Gödel is a declarative, general-purpose programming language in
          the family of logic programming languages. It is a strongly
          typed language, the type system being based on many-sorted
          logic with parametric polymorphism. It has a module system.
          Gödel supports infinite precision integers, infinite precision
          rationals, and also floating-point numbers. It can solve
          constraints over finite domains of integers and also linear
          rational constraints. It supports processing of finite sets. It
          also has a flexible computation rule and a pruning operator
          which generalizes the commit of the concurrent logic
          programming languages. Considerable emphasis is placed on
          Gödel's meta- logical facilities which provide significant
          support for meta-programs that do analysis, transformation,
          compilation, verification, debugging, and so on.
          
   LIFE
          Web page: [35]www.isg.sfu.ca/life
          LIFE (Logic, Inheritance, Functions, and Equations) is an
          experimental programming language proposing to integrate three
          orthogonal programming paradigms proven useful for symbolic
          computation. From the programmer's standpoint, it may be
          perceived as a language taking after logic programming,
          functional programming, and object-oriented programming. From a
          formal perspective, it may be seen as an instance (or rather, a
          composition of three instances) of a Constraint Logic
          Programming scheme due to Hoehfeld and Smolka refining that of
          Jaffar and Lassez.
          
   CLisp (Lisp)
          FTP site: [36]sunsite.unc.edu/pub/Linux/devel/lang/lisp/
          CLISP is a Common Lisp implementation by Bruno Haible and
          Michael Stoll. It mostly supports the Lisp described by
          [37]'Common LISP: The Language (2nd edition)' and the ANSI
          Common Lisp standard. CLISP includes an interpreter, a
          byte-compiler, a large subset of CLOS (Object-Oriented Lisp) ,
          a foreign language interface and, for some machines, a screen
          editor.
          
          The user interface language (English, German, French) is chosen
          at run time. Major packages that run in CLISP include CLX &
          Garnet. CLISP needs only 2 MB of memory.
          
   CMU Common Lisp
          Web page: [38]www.mv.com/users/pw/lisp/index.html
          FTP site: [39]sunsite.unc.edu/pub/Linux/devel/lang/lisp/
          CMU Common Lisp is a public domain "industrial strength" Common
          Lisp programming environment. Many of the X3j13 changes have
          been incorporated into CMU CL. Wherever possible, this has been
          done so as to transparently allow the use of either CLtL1 or
          proposed ANSI CL. Probably the new features most interesting to
          users are SETF functions, LOOP and the WITH-COMPILATION-UNIT
          macro.
          
   GCL (Lisp)
          FTP site: [40]sunsite.unc.edu/pub/Linux/devel/lang/lisp/
          GNU Common Lisp (GCL) has a compiler and interpreter for Common
          Lisp. It used to be known as Kyoto Common Lisp. It is very
          portable and extremely efficient on a wide class of
          applications. It compares favorably in performance with
          commercial Lisps on several large theorem-prover and symbolic
          algebra systems. It supports the CLtL1 specification but is
          moving towards the proposed ANSI definition. GCL compiles to C
          and then uses the native optimizing C compilers (e.g., GCC). A
          function with a fixed number of args and one value turns into a
          C function of the same number of args, returning one value, so
          GCL is maximally efficient on such calls. It has a conservative
          garbage collector which allows great freedom for the C compiler
          to put Lisp values in arbitrary registers.
          
          It has a source level Lisp debugger for interpreted code, with
          display of source code in an Emacs window. Its profiling tools
          (based on the C profiling tools) count function calls and the
          time spent in each function.
          
   Mercury
          Web page: [41]www.cs.mu.oz.au/research/mercury/
          Mercury is a new, purely declarative logic programming
          language. Like Prolog and other existing logic programming
          languages, it is a very high-level language that allows
          programmers to concentrate on the problem rather than the
          low-level details such as memory management. Unlike Prolog,
          which is oriented towards exploratory programming, Mercury is
          designed for the construction of large, reliable, efficient
          software systems by teams of programmers. As a consequence,
          programming in Mercury has a different flavor than programming
          in Prolog.
          
   DFKI OZ
          Web page: [42]www.ps.uni-sb.de/oz/
          FTP site: [43]ps-ftp.dfki.uni-sb.de/pub/oz2/
          Oz is a high-level programming language designed for concurrent
          symbolic computation. It is based on a new computation model
          providing a uniform and simple foundation for several
          programming paradigms, including higher-order functional,
          constraint logic, and concurrent object-oriented programming.
          Oz is designed as a successor to languages such as Lisp, Prolog
          and Smalltalk, which fail to support applications that require
          concurrency, reactivity, and real-time control.
          
          DFKI Oz is an interactive implementation of Oz featuring a
          programming interface based on GNU Emacs, a concurrent browser,
          an object-oriented interface to Tcl/Tk, powerful
          interoperability features (sockets, C, C++), an incremental
          compiler, a garbage collector, and support for stand-alone
          applications. Performance is competitive with commercial Prolog
          and Lisp systems.
          
   BinProlog
          Web site(documentation):
          [44]clement.info.umoncton.ca/BinProlog/UNCOMPRESSED/doc/html/ar
          t.html
          FTP site(source): [45]clement.info.umoncton.ca/BinProlog
          FTP site(binary):
          [46]clement.info.umoncton.ca/BinProlog/UNCOMPRESSED/bin
          BinProlog is a fast and compact Prolog compiler, based on the
          transformation of Prolog to binary clauses. The compilation
          technique is similar to the Continuation Passing Style
          transformation used in some ML implementations. BinProlog 5.00
          is also probably the first Prolog system featuring dynamic
          recompilation of asserted predicates (a technique similar to
          the one used in some object oriented languages like SELF 4.0),
          and a very efficient segment preserving copying heap garbage
          collector.
          
          Although it (used to) incorporate some last minute research
          experiments, which might look adventurous at the first sight,
          BinProlog is a fairly robust and complete Prolog implementation
          featuring both C-emulated execution and generation of
          stand-alone applications by compilation to C.
          
   SWI Prolog
          Web page: [47]swi.psy.uva.nl/projects/xpce/SWI-Prolog.html
          FTP site: [48]swi.psy.uva.nl/pub/SWI-Prolog/
          SWI is a free version of prolog in the Edinburgh Prolog family
          (thus making it very similar to Quintus and many other
          versions). With: a large library of built in predicates, a
          module system, garbage collection, a two-way interface with the
          C language, plus many other features. It is meant as a
          educational language, so it's compiled code isn't the fastest.
          Although it similarity to Quintus allows for easy porting.
          
          XPCE is freely available in binary form for the Linux version
          of SWI-prolog. XPCE is an object oriented X-windows GUI
          development package/environment.
          
   Kali Scheme
          Web site: [49]www.neci.nj.nec.com/PLS/Kali.html
          Kali Scheme is a distributed implementation of Scheme that
          permits efficient transmission of higher-order objects such as
          closures and continuations. The integration of distributed
          communication facilities within a higher-order programming
          language engenders a number of new abstractions and paradigms
          for distributed computing. Among these are user-specified
          load-balancing and migration policies for threads,
          incrementally-linked distributed computations, agents, and
          parameterized client-server applications. Kali Scheme supports
          concurrency and communication using first-class procedures and
          continuations. It integrates procedures and continuations into
          a message-based distributed framework that allows any Scheme
          object (including code vectors) to be sent and received in a
          message.
          
   RScheme
          Web site:[50]www.rosette.com/~donovan/rs/rscheme.html
          FTP site: [51]ftp.rosette.com/pub/rscheme
          RScheme is an object-oriented, extended version of the Scheme
          dialect of Lisp. RScheme is freely redistributable, and offers
          reasonable performance despite being extraordinarily portable.
          RScheme can be compiled to C, and the C can then compiled with
          a normal C compiler to generate machine code. By default,
          however, RScheme compiles to bytecodes which are interpreted by
          a (runtime) virtual machine. This ensures that compilation is
          fast and keeps code size down. In general, we recommend using
          the (default) bytecode code generation system, and only
          compiling your time-critical code to machine code. This allows
          a nice adjustment of space/time tradeoffs. (see web site for
          details)
          
   Scheme48
          Web site: [52]www-swiss.ai.mit.edu/~jar/s48.html (download from
          ftp site)
          FTP site: [53]swiss-ftp.ai.mit.edu:/archive/s48/
          Scheme 48 is a Scheme implementation based on a virtual machine
          architecture. Scheme 48 is designed to be straightforward,
          flexible, reliable, and fast. It should be easily portable to
          32-bit byte-addressed machines that have POSIX and ANSI C
          support. In addition to the usual Scheme built-in procedures
          and a development environment, library software includes
          support for hygienic macros (as described in the Revised^4
          Scheme report), multitasking, records, exception handling, hash
          tables, arrays, weak pointers, and FORMAT. Scheme 48 implements
          and exploits an experimental module system loosely derived from
          Standard ML and Scheme Xerox. The development environment
          supports interactive changes to modules and interfaces.
          
   SCM (Scheme)
          Web site: [54]www-swiss.ai.mit.edu/~jaffer/SCM.html
          FTP site: [55]swiss-ftp.ai.mit.edu:/archive/scm/
          SCM conforms to the Revised^4 Report on the Algorithmic
          Language Scheme and the IEEE P1178 specification. Scm is
          written in C. It uses the following utilities (all available at
          the ftp site).
          
          + SLIB (Standard Scheme Library) is a portable Scheme library
            which is intended to provide compatibility and utility
            functions for all standard Scheme implementations, including
            SCM, Chez, Elk, Gambit, MacScheme, MITScheme, scheme->C,
            Scheme48, T3.1, and VSCM, and is available as the file
            slib2c0.tar.gz. Written by Aubrey Jaffer.
          + JACAL is a symbolic math system written in Scheme, and is
            available as the file jacal1a7.tar.gz.
          + Interfaces to standard libraries including REGEX string
            regular expression matching and the CURSES screen management
            package.
          + Available add-on packages including an interactive debugger,
            database, X-window graphics, BGI graphics, Motif, and
            Open-Windows packages.
          + A compiler (HOBBIT, available separately) and dynamic linking
            of compiled modules.
            
   Shift [New]
          Web site: [56]www.path.berkeley.edu/shift/
          Shift is a programming language for describing dynamic networks
          of hybrid automata. Such systems consist of components which
          can be created, interconnected and destroyed as the system
          evolves. Components exhibit hybrid behavior, consisting of
          continuous-time phases separated by discrete-event transitions.
          Components may evolve independently, or they may interact
          through their inputs, outputs and exported events. The
          interaction network itself may evolve.
          
Traditional Artificial Intelligence

   Traditional AI is based around the ideas of logic, rule systems,
   linguistics, and the concept of rationality. At its roots are
   programming languages such as Lisp and Prolog. Expert systems are the
   largest successful example of this paradigm. An expert system consists
   of a detailed knowledge base and a complex rule system to utilize it.
   Such systems have been used for such things as medical diagnosis
   support and credit checking systems.
   
  AI class/code libraries
  
   These are libraries of code or classes for use in programming within
   the artificial intelligence field. They are not meant as stand alone
   applications, but rather as tools for building your own applications.
   
   AI Search
          FTP site: [57]ftp.icce.rug.nl/pub/peter/
          Submitted by: [58]Peter M. Bouthoorn
          Basically, the library offers the programmer a set of search
          algorithms that may be used to solve all kind of different
          problems. The idea is that when developing problem solving
          software the programmer should be able to concentrate on the
          representation of the problem to be solved and should not need
          to bother with the implementation of the search algorithm that
          will be used to actually conduct the search. This idea has been
          realized by the implementation of a set of search classes that
          may be incorporated in other software through C++'s features of
          derivation and inheritance. The following search algorithms
          have been implemented:
          
          - depth-first tree and graph search.
          - breadth-first tree and graph search.
          - uniform-cost tree and graph search.
          - best-first search.
          - bidirectional depth-first tree and graph search.
          - bidirectional breadth-first tree and graph search.
          - AND/OR depth tree search.
          - AND/OR breadth tree search.
          Peter plans to release a new version of the library soon, which
          will also be featured in a book about C++ and AI to appear this
          year.
          
   Chess In Lisp (CIL)
          FTP site: [59]chess.onenet.net/pub/chess/uploads/projects/
          The CIL (Chess In Lisp) foundation is a Common Lisp
          implementaion of all the core functions needed for development
          of chess applications. The main purpose of the CIL project is
          to get AI researchers interested in using Lisp to work in the
          chess domain.
          
   DAI [New]
          Web site: [60]starship.skyport.net/crew/gandalf/DNET/AI
          A library for the Python programming language that provides an
          object oriented interface to the CLIPS expert system tool. It
          includes an interface to COOL (CLIPS Object Oriented Language)
          that allows:
          
          + Investigate COOL classes
          + Create and manipulate with COOL instances
          + Manipulate with COOL message-handler's
          + Manipulate with Modules
            
   Nyquist [New]
          Web site:
          [61]www.cs.cmu.edu/afs/cs.cmu.edu/project/music/web/music.html
          The Computer Music Project at CMU is developing computer music
          and interactive performance technology to enhance human musical
          experience and creativity. This interdisciplinary effort draws
          on Music Theory, Cognitive Science, Artificial Intelligence and
          Machine Learning, Human Computer Interaction, Real-Time
          Systems, Computer Graphics and Animation, Multimedia,
          Programming Languages, and Signal Processing. A paradigmatic
          example of these interdisciplinary efforts is the creation of
          interactive performances that couple human musical
          improvisation with intelligent computer agents in real-time.
          
   Screamer
          Web site: [62]www.cis.upenn.edu/~screamer-tools/home.html
          Screamer is an extension of Common Lisp that adds support for
          nondeterministic programming. Screamer consists of two levels.
          The basic nondeterministic level adds support for backtracking
          and undoable side effects. On top of this nondeterministic
          substrate, Screamer provides a comprehensive constraint
          programming language in which one can formulate and solve mixed
          systems of numeric and symbolic constraints. Together, these
          two levels augment Common Lisp with practically all of the
          functionality of both Prolog and constraint logic programming
          languages such as CHiP and CLP(R). Furthermore, Screamer is
          fully integrated with Common Lisp. Screamer programs can
          coexist and interoperate with other extensions to Common Lisp
          such as CLOS, CLIM and Iterate.
          
  AI software kits, applications, etc.
  
   These are various applications, software kits, etc. meant for research
   in the field of artificial intelligence. Their ease of use will vary,
   as they were designed to meet some particular research interest more
   than as an easy to use commercial package.
   
   ASA - Adaptive Simulated Annealing
          Web site: [63]www.ingber.com/#ASA-CODE
          FTP site: [64]ftp.ingber.com/
          ASA (Adaptive Simulated Annealing) is a powerful global
          optimization C-code algorithm especially useful for nonlinear
          and/or stochastic systems.
          
          ASA is developed to statistically find the best global fit of a
          nonlinear non-convex cost-function over a D-dimensional space.
          This algorithm permits an annealing schedule for 'temperature'
          T decreasing exponentially in annealing-time k, T = T_0 exp(-c
          k^1/D). The introduction of re-annealing also permits
          adaptation to changing sensitivities in the multi-dimensional
          parameter-space. This annealing schedule is faster than fast
          Cauchy annealing, where T = T_0/k, and much faster than
          Boltzmann annealing, where T = T_0/ln k.
          
   Babylon
          FTP site: [65]ftp.gmd.de/gmd/ai-research/Software/Babylon/
          BABYLON is a modular, configurable, hybrid environment for
          developing expert systems. Its features include objects, rules
          with forward and backward chaining, logic (Prolog) and
          constraints. BABYLON is implemented and embedded in Common
          Lisp.
          
   CLEARS
          Web site: [66]www.coli.uni-sb.de/~clears/
          The CLEARS system is an interactive graphical environment for
          computational semantics. The tool allows exploration and
          comparison of different semantic formalisms, and their
          interaction with syntax. This enables the user to get an idea
          of the range of possibilities of semantic construction, and
          also where there is real convergence between theories.
          
   CLIPS
          Web site: [67]www.jsc.nasa.gov/~clips/CLIPS.html
          FTP site:
          [68]cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/areas/ex
          pert/systems/clips
          CLIPS is a productive development and delivery expert system
          tool which provides a complete environment for the construction
          of rule and/or object based expert systems.
          
          CLIPS provides a cohesive tool for handling a wide variety of
          knowledge with support for three different programming
          paradigms: rule-based, object-oriented and procedural.
          Rule-based programming allows knowledge to be represented as
          heuristics, or "rules of thumb," which specify a set of actions
          to be performed for a given situation. Object-oriented
          programming allows complex systems to be modeled as modular
          components (which can be easily reused to model other systems
          or to create new components). The procedural programming
          capabilities provided by CLIPS are similar to capabilities
          found in languages such as C, Pascal, Ada, and LISP.
          
   EMA-XPS - A Hybrid Graphic Expert System Shell
          Web site: [69]wmwap1.math.uni-wuppertal.de:80/EMA-XPS/
          EMA-XPS is a hybrid graphic expert system shell based on the
          ASCII-oriented shell Babylon 2.3 of the German National
          Research Center for Computer Sciences (GMD). In addition to
          Babylon's AI-power (object oriented data representation,
          forward and backward chained rules - collectible into sets,
          horn clauses, and constraint networks) a graphic interface
          based on the X11 Window System and the OSF/Motif Widget Library
          has been provided.
          
   FOOL & FOX
          FTP site: [70]ntia.its.bldrdoc.gov/pub/fuzzy/prog/
          FOOL stands for the Fuzzy Organizer OLdenburg. It is a result
          from a project at the University of Oldenburg. FOOL is a
          graphical user interface to develop fuzzy rulebases. FOOL will
          help you to invent and maintain a database that specifies the
          behavior of a fuzzy-controller or something like that.
          
          FOX is a small but powerful fuzzy engine which reads this
          database, reads some input values and calculates the new
          control value.
          
   FUF and SURGE 
          Web site: [71]www.dfki.de/lt/registry/generation/fuf.html
          FTP site: [72]ftp.cs.columbia.edu/pub/fuf/
          FUF is an extended implementation of the formalism of
          functional unification grammars (FUGs) introduced by Martin Kay
          specialized to the task of natural language generation. It adds
          the following features to the base formalism:
          
          + Types and inheritance.
          + Extended control facilities (goal freezing, intelligent
            backtracking).
          + Modular syntax.
            
          These extensions allow the development of large grammars which
          can be processed efficiently and can be maintained and
          understood more easily. SURGE is a large syntactic realization
          grammar of English written in FUF. SURGE is developed to serve
          as a black box syntactic generation component in a larger
          generation system that encapsulates a rich knowledge of English
          syntax. SURGE can also be used as a platform for exploration of
          grammar writing with a generation perspective.
          
   The Grammar Workbench
          Web site: [73]www.cs.kun.nl/agfl/GWB.html
          The Grammar Workbench, or GWB for short, is an environment for
          the comfortable development of Affix Grammars in the
          AGFL-formalism. Its purposes are:
          
          + to allow the user to input, inspect and modify a grammar;
          + to perform consistency checks on the grammar;
          + to compute grammar properties;
          + to generate example sentences;
          + to assist in performing grammar transformations.
            
   GSM Suite [New]
          Web site: [74]www.slip.net/~andrewm/gsm/
          The GSM Suite is a set of programs for using Finite State
          Machines in a graphical fashion. The suite consists of programs
          that edit, compile, and print state machines. Included in the
          suite is an editor program, gsmedit, a compiler, gsm2cc, that
          produces a C++ implementation of a state machine, a PostScript
          generator, gsm2ps, and two other minor programs. GSM is
          licensed under the GNU Public License and so is free for your
          use under the terms of that license.
          
   Illuminator
          Web site:
          [75]documents.cfar.umd.edu/resources/source/illuminator.html
          Illuminator is a toolset for developing OCR and Image
          Understanding applications. Illuminator has two major parts: a
          library for representing, storing and retrieving OCR
          information, heretofore called dafslib, and an X-Windows "DAFS"
          file viewer, called illum. Illuminator and DAFS lib were
          designed to supplant existing OCR formats and become a standard
          in the industry. They particularly are extensible to handle
          more than just English. The features of this release:
          
          + 5 magnification levels for images
          + flagged characters and words
          + unicode support -- American, British, French, German, Greek,
            Italian, MICR, Norwegian, Russian, Spanish, Swedish,
            keyboards
          + reads DAFS, TIFF's, PDA's (image only)
          + save to DAFS, ASCII/UTF or Unicode
          + Entity Viewer - shows properties, character choices, bounding
            boxes image fragment for a selected entity, change type,
            change content, hierarchy mode
            
   Jess, the Java Expert System Shell
          Web site: [76]herzberg.ca.sandia.gov/jess/
          Jess is a clone of the popular CLIPS expert system shell
          written entirely in Java. With Jess, you can conveniently give
          your applets the ability to 'reason'. Jess is compatible with
          all versions of Java starting with version 1.0.2. Jess
          implements the following constructs from CLIPS: defrules,
          deffunctions, defglobals, deffacts, and deftemplates.
          
   learn
          FTP site: [77]sunsite.unc.edu/pub/Linux/apps/cai/
          Learn is a vocable learning program with memory model.
          
   Otter: An Automated Deduction System
          Web site: [78]www.mcs.anl.gov/home/mccune/ar/otter
          Our current automated deduction system Otter is designed to
          prove theorems stated in first-order logic with equality.
          Otter's inference rules are based on resolution and
          paramodulation, and it includes facilities for term rewriting,
          term orderings, Knuth-Bendix completion, weighting, and
          strategies for directing and restricting searches for proofs.
          Otter can also be used as a symbolic calculator and has an
          embedded equational programming system.
          
   RIPPER
          Web site: [79]www.research.att.com/~wcohen/ripperd.html
          Ripper is a system for fast effective rule induction. Given a
          set of data, Ripper will learn a set of rules that will predict
          the patterns in the data. Ripper is written in ASCI C and comes
          with documentation and some sample problems.
          
   SNePS
          Web site: [80]www.cs.buffalo.edu/pub/sneps/WWW/
          FTP site: [81]ftp.cs.buffalo.edu/pub/sneps/
          The long-term goal of The SNePS Research Group is the design
          and construction of a natural-language-using computerized
          cognitive agent, and carrying out the research in artificial
          intelligence, computational linguistics, and cognitive science
          necessary for that endeavor. The three-part focus of the group
          is on knowledge representation, reasoning, and natural-language
          understanding and generation. The group is widely known for its
          development of the SNePS knowledge representation/reasoning
          system, and Cassie, its computerized cognitive agent.
          
   Soar
          Web site: [82]www.isi.edu/soar/soar.html
          FTP site: [83]cs.cmu.edu/afs/cs/project/soar/public/Soar6/
          Soar has been developed to be a general cognitive architecture.
          We intend ultimately to enable the Soar architecture to:
          
          + work on the full range of tasks expected of an intelligent
            agent, from highly routine to extremely difficult, open-ended
            problems
          + represent and use appropriate forms of knowledge, such as
            procedural, declarative, episodic, and possibly iconic
          + employ the full range of problem solving methods
          + interact with the outside world and
          + learn about all aspects of the tasks and its performance on
            them.
            
          In other words, our intention is for Soar to support all the
          capabilities required of a general intelligent agent.
          
   TCM (Toolkit for Conceptual Modeling)
          Web site: [84]www.cs.vu.nl/~tcm/
          FTP site: [85]ftp.cs.vu.nl/pub/tcm/
          TCM (Toolkit for Conceptual Modeling) is our suite of graphical
          editors. TCM contains graphical editors for Entity-Relationship
          diagrams, Class-Relationship diagrams, Data and Event Flow
          diagrams, State Transition diagrams, Jackson Process Structure
          diagrams and System Network diagrams, Function Refinement trees
          and various table editors, such as a Function-Entity table
          editor and a Function Decomposition table editor. TCM is easy
          to use and performs numerous consistency checks, some of them
          immediately, some of them upon request.
          
   WEKA [New]
          Web site: [86]lucy.cs.waikato.ac.nz/~ml/
          WEKA (Waikato Environment for Knowledge Analysis) is an
          state-of-the-art facility for applying machine learning
          techniques to practical problems. It is a comprehensive
          software "workbench" that allows people to analyse real-world
          data. It integrates different machine learning tools within a
          common framework and a uniform user interface. It is designed
          to support a "simplicity-first" methodology, which allows users
          to experiment interactively with simple machine learning tools
          before looking for more complex solutions.
          
Connectionism

   Connectionism is a technical term for a group of related techniques.
   These techniques include areas such as Artificial Neural Networks,
   Semantic Networks and a few other similar ideas. My present focus is
   on neural networks (though I am looking for resources on the other
   techniques). Neural networks are programs designed to simulate the
   workings of the brain. They consist of a network of small
   mathematical-based nodes, which work together to form patterns of
   information. They have tremendous potential and currently seem to be
   having a great deal of success with image processing and robot
   control.
   
  Connectionist class/code libraries
  
   These are libraries of code or classes for use in programming within
   the Connectionist field. They are not meant as stand alone
   applications, but rather as tools for building your own applications.
   
   ANSI-C Neural Networks
          Web site: [87]www.geocities.com/CapeCanaveral/1624/
          This site contains ANSC-C source code for 8 types of neural
          nets, including:
          
          + Adaline Network
          + Backpropagation
          + Hopfield Model
          + (BAM) Bidirectional Associative Memory
          + Boltzmann Machine
          + Counterpropagation
          + (SOM) Self-Organizing Map
          + (ART1) Adaptive Resonance Theory
            
          They were designed to help turn the theory of a particular
          network model into the design for a simulator implementation ,
          and to help with embeding an actual application into a
          particular network model.
          
   BELIEF [New]
          Web site:
          [88]www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/reason
          ng/probabl/belief/0.html
          BELIEF is a Common Lisp implementation of the Dempster and Kong
          fusion and propagation algorithm for Graphical Belief Function
          Models and the Lauritzen and Spiegelhalter algorithm for
          Graphical Probabilistic Models. It includes code for
          manipulating graphical belief models such as Bayes Nets and
          Relevance Diagrams (a subset of Influence Diagrams) using both
          belief functions and probabilities as basic representations of
          uncertainty. It uses the Shenoy and Shafer version of the
          algorithm, so one of its unique features is that it supports
          both probability distributions and belief functions. It also
          has limited support for second order models (probability
          distributions on parameters).
          
   IDEAL [New]
          Web site: [89]www.rpal.rockwell.com/ideal.html
          IDEAL is a test bed for work in influence diagrams and Bayesian
          networks. It contains various inference algorithms for belief
          networks and evaluation algorithms for influence diagrams. It
          contains facilities for creating and editing influence diagrams
          and belief networks.
          
          IDEAL is written in pure Common Lisp and so it will run in
          Common Lisp on any platform. The emphasis in writing IDEAL has
          been on code clarity and providing high level programming
          abstractions. It thus is very suitable for experimental
          implementations which need or extend belief network technology.
          
          At the highest level, IDEAL can be used as a subroutine library
          which provides belief network inference and influence diagram
          evaluation as a package. The code is documented in a detailed
          manual and so it is also possible to work at a lower level on
          extensions of belief network methods.
          
          IDEAL comes with an optional graphic interface written in CLIM.
          If your Common Lisp also has CLIM, you can run the graphic
          interface.
          
   Matrix Class
          FTP site: [90]pink.cs.ucla.edu/pub/
          A simple, fast, efficient C++ Matrix class designed for
          scientists and engineers. The Matrix class is well suited for
          applications with complex math algorithms. As an demonstration
          of the Matrix class, it was used to implement the backward
          error propagation algorithm for a multi-layer feed-forward
          artificial neural network.
          
   Pulcinella
          Web site: [91]iridia.ulb.ac.be/pulcinella/Welcome.html
          Pulcinella is written in CommonLisp, and appears as a library
          of Lisp functions for creating, modifying and evaluating
          valuation systems. Alternatively, the user can choose to
          interact with Pulcinella via a graphical interface (only
          available in Allegro CL). Pulcinella provides primitives to
          build and evaluate uncertainty models according to several
          uncertainty calculi, including probability theory, possibility
          theory, and Dempster-Shafer's theory of belief functions; and
          the possibility theory by Zadeh, Dubois and Prade's. A User's
          Manual is available on request.
          
   S-ElimBel [New]
          Web site: [92]www.spaces.uci.edu/thiery/elimbel/
          S-ElimBel is an algorithm that computes the belief in a
          Bayesian network, implemented in MIT-Scheme. This algorithm has
          the particularity of being rather easy to understand. Moreover,
          one can apply it to any kind of Bayesian network - it being
          singly connected or muliply connected. It is, however, less
          powerful than the standard algorithm of belief propagation.
          Indeed, the computation has to be reconducted entirely for each
          new evidence added to the network. Also, one needs to run the
          algorithm as many times as one has nodes for which the belief
          is wanted.
          
   Software for Flexible Bayesian Modeling [New]
          Web site: [93]www.cs.utoronto.ca/~radford/fbm.software.html
          This software implements flexible Bayesian models for
          regression and classification applications that are based on
          multilayer perceptron neural networks or on Gaussian processes.
          The implementation uses Markov chain Monte Carlo methods.
          Software modules that support Markov chain sampling are
          included in the distribution, and may be useful in other
          applications.
          
   Spiderweb2 [New]
          Web site: 
          A C++ artificial neual net library. Spiderweb2 is a complete
          rewrite of the original Spiderweb library, it has grown into a
          much more flexible and object-oriented system. The biggest
          change is that each neuron object is responsible for its own
          activations and updates, with the network providing only the
          scheduling aspect. This is a very powerful change, and it
          allows easy modification and experimentation with various
          network architectures and neuron types.
          
          There is still a lack of documentation and support for file
          I/O, but that will eventually get done.
          
   Symbolic Probabilistic Inference (SPI)
          FTP site: [94]ftp.engr.orst.edu/pub/dambrosi/spi/
          Paper (ijar-94.ps): [95]ftp.engr.orst.edu/pub/dambrosi/
          Contains Common Lisp function libraries to implement SPI type
          baysean nets. Documentation is very limited.
          Features:
          
        Probabilities, Local Expression Language Utilities, Explanation,
            Dynamic Models, and a TCL/TK based GUI.
            
   TresBel
          FTP site: [96]iridia.ulb.ac.be/pub/hongxu/software/
          Libraries containing (Allegro) Common Lisp code for Belief
          Functions (aka. Dempster-Shafer evidential reasoning) as a
          representation of uncertainty. Very little documentation. Has a
          limited GUI.
          
   Various (C++) Neural Networks
          Web site: [97]www.mcs.com/~drt/svbp.html
          Submitted by: [98]Don Tveter
          Example neural net codes from the book, [99]The Basis of
          Artificial Intelligence. These are simple example codes of
          these various neural nets. They work well as a good starting
          point for simple experimentation and for learning what the code
          is like behind the simulators. The types of networks available
          on this site are: (implemented in C++)
          
          + The Backprop Package
          + The Nearest Neighbor Algorithms
          + The Interactive Activation Algorithm
          + The Hopfield and Boltzman machine Algorithms
          + The Linear Pattern Classifier
          + ART I
          + Bi-Directional Associative Memory
          + The Feedforward Counter-Propagation Network
            
  Connectionist software kits/applications
  
   These are various applications, software kits, etc. meant for research
   in the field of Connectionism. Their ease of use will vary, as they
   were designed to meet some particular research interest more than as
   an easy to use commercial package.
   
   Aspirin/MIGRAINES (am6.tar.Z on ftp site)
          FTP site:
          [100]sunsite.unc.edu/pub/academic/computer-science/neural-netwo
          rks/programs/Aspirin/
          The software that we are releasing now is for creating, and
          evaluating, feed-forward networks such as those used with the
          backpropagation learning algorithm. The software is aimed both
          at the expert programmer/neural network researcher who may wish
          to tailor significant portions of the system to his/her precise
          needs, as well as at casual users who will wish to use the
          system with an absolute minimum of effort.
          
   JavaBayes [New]
          Web site: [101]www.cs.cmu.edu/People/javabayes/index.html/
          The JavaBayes system is a set of tools, containing a graphical
          editor, a core inference engine and a parser. JavaBayes can
          produce:
          
          + the marginal distribution for any variable in a network.
          + the expectations for univariate functions (for example,
            expected value for variables).
          + configurations with maximum a posteriori probability.
          + configurations with maximum a posteriori expectation for
            univariate functions.
            
   Neureka ANS (nn/xnn)
          Web site: [102]www.bgif.no/neureka/
          FTP site: [103]ftp.ii.uib.no/pub/neureka/linux/
          nn is a high-level neural network specification language. The
          current version is best suited for feed-forward nets, but
          recurrent models can and have been implemented, e.g. Hopfield
          nets, Jordan/Elman nets, etc. In nn, it is easy to change
          network dynamics. The nn compiler can generate C code or
          executable programs (so there must be a C compiler available),
          with a powerful command line interface (but everything may also
          be controlled via the graphical interface, xnn). It is possible
          for the user to write C routines that can be called from inside
          the nn specification, and to use the nn specification as a
          function that is called from a C program. Please note that no
          programming is necessary in order to use the network models
          that come with the system (`netpack').
          
          xnn is a graphical front end to networks generated by the nn
          compiler, and to the compiler itself. The xnn graphical
          interface is intuitive and easy to use for beginners, yet
          powerful, with many possibilities for visualizing network data.
          
          NOTE: You have to run the install program that comes with this
          to get the license key installed. It gets put (by default) in
          /usr/lib. If you (like myself) want to install the package
          somewhere other than in the /usr directory structure (the
          install program gives you this option) you will have to set up
          some environmental variables (NNLIBDIR & NNINCLUDEDIR are
          required). You can read about these (and a few other optional
          variables) in appendix A of the documentation (pg 113).
          
   PDP++
          Web site: [104]www.cnbc.cmu.edu/PDP++/
          FTP site (US): [105]cnbc.cmu.edu/pub/pdp++/
          FTP site (Europe): [106]unix.hensa.ac.uk/mirrors/pdp++/ 
          As the field of Connectionist modeling has grown, so has the
          need for a comprehensive simulation environment for the
          development and testing of Connectionist models. Our goal in
          developing PDP++ has been to integrate several powerful
          software development and user interface tools into a general
          purpose simulation environment that is both user friendly and
          user extensible. The simulator is built in the C++ programming
          language, and incorporates a state of the art script
          interpreter with the full expressive power of C++. The
          graphical user interface is built with the Interviews toolkit,
          and allows full access to the data structures and processing
          modules out of which the simulator is built. We have
          constructed several useful graphical modules for easy
          interaction with the structure and the contents of neural
          networks, and we've made it possible to change and adapt many
          things. At the programming level, we have set things up in such
          a way as to make user extensions as painless as possible. The
          programmer creates new C++ objects, which might be new kinds of
          units or new kinds of processes; once compiled and linked into
          the simulator, these new objects can then be accessed and used
          like any other.
          
   Simple Neural Net (in Python)
          Web site: [107]starship.skyport.net/crew/amk/unmaintained/
          Simple neural network code, which implements a class for
          3-level networks (input, hidden, and output layers). The only
          learning rule implemented is simple backpropagation. No
          documentation (or even comments) at all, because this is simply
          code that I use to experiment with. Includes modules containing
          sample datasets from Carl G. Looney's NN book. Requires the
          Numeric extensions.
          
   SCNN
          Web site:
          [108]apx00.physik.uni-frankfurt.de/e_ag_rt/cnn/SCNN/homepage.ht
          ml
          SCNN is an universal simulating system for Cellular Neural
          Networks (CNN). CNN are analog processing neural networks with
          regular and local interconnections, governed by a set of
          nonlinear ordinary differential equations. Due to their local
          connectivity, CNN are realized as VLSI chips, which operates at
          very high speed.
          
   Semantic Networks in Python
          Web site: [109]www-acs.ucsd.edu/~jstrout/python/ai/
          The semnet.py module defines several simple classes for
          building and using semantic networks. A semantic network is a
          way of representing knowledge, and it enables the program to do
          simple reasoning with very little effort on the part of the
          programmer.
          
          The following classes are defined:
          
          + Entity: This class represents a noun; it is something which
            can be related to other things, and about which you can store
            facts.
          + Relation: A Relation is a type of relationship which may
            exist between two entities. One special relation, "IS_A", is
            predefined because it has special meaning (a sort of logical
            inheritance).
          + Fact: A Fact is an assertion that a relationship exists
            between two entities.
            
          With these three object types, you can very quickly define
          knowledge about a set of objects, and query them for logical
          conclusions.
          
   SNNS
          Web site:
          [110]www.informatik.uni-stuttgart.de/ipvr/bv/projekte/snns/snns
          .html
          FTP site: [111]ftp.informatik.uni-stuttgart.de/pub/SNNS/
          Stuttgart Neural Net Simulator (version 4.1). An awesome neural
          net simulator. Better than any commercial simulator I've seen.
          The simulator kernel is written in C (it's fast!). It supports
          over 20 different network architectures, has 2D and 3D X-based
          graphical representations, the 2D GUI has an integrated network
          editor, and can generate a separate NN program in C.
          SNNS is very powerful, though a bit difficult to learn at
          first. To help with this it comes with example networks and
          tutorials for many of the architectures.
          ENZO, a supplementary system allows you to evolve your networks
          with genetic algorithms.
          
          The Readme.linux file that comes with this package must be old.
          It's instructions for building the package are wrong. I've
          edited it to reflect what I had to do to get the package to
          compile. Please download [112]SNNS.Readme.linux and use it
          instead of the Readme.linux file that comes with the
          distribution.
          
   SPRLIB/ANNLIB
          Web site: [113]www.ph.tn.tudelft.nl/~sprlib/
          SPRLIB (Statistical Pattern Recognition Library) was developed
          to support the easy construction and simulation of pattern
          classifiers. It consist of a library of functions (written in
          C) that can be called from your own program. Most of the
          well-known classifiers are present (k-nn, Fisher, Parzen,
          ....), as well as error estimation and dataset generation
          routines.
          
          ANNLIB (Artificial Neural Networks Library) is a neural network
          simulation library based on the data architecture laid down by
          SPRLIB. The library contains numerous functions for creating,
          training and testing feed-forward networks. Training algorithms
          include back-propagation, pseudo-Newton, Levenberg-Marquardt,
          conjugate gradient descent, BFGS.... Furthermore, it is
          possible - due to the datastructures' general applicability -
          to build Kohonen maps and other more exotic network
          architectures using the same data types.
          
Evolutionary Computing

   Evolutionary computing is actually a broad term for a vast array of
   programming techniques, including genetic algorithms, complex adaptive
   systems, evolutionary programming, etc. The main thrust of all these
   techniques is the idea of evolution. The idea that a program can be
   written that will evolve toward a certain goal. This goal can be
   anything from solving some engineering problem to winning a game.
   
  EC class/code libraries
  
   These are libraries of code or classes for use in programming within
   the evolutionary computation field. They are not meant as stand alone
   applications, but rather as tools for building your own applications.
   
   FORTRAN GA
          Web site: [114]www.staff.uiuc.edu/~carroll/ga.html
          This program is a FORTRAN version of a genetic algorithm
          driver. This code initializes a random sample of individuals
          with different parameters to be optimized using the genetic
          algorithm approach, i.e. evolution via survival of the fittest.
          The selection scheme used is tournament selection with a
          shuffling technique for choosing random pairs for mating. The
          routine includes binary coding for the individuals, jump
          mutation, creep mutation, and the option for single-point or
          uniform crossover. Niching (sharing) and an option for the
          number of children per pair of parents has been added. More
          recently, an option for the use of a micro-GA has been added.
          
   GAGS
          Web site: [115]kal-el.ugr.es/gags.html
          FTP site: [116]kal-el.ugr.es/GAGS/
          Genetic Algorithm application generator and class library
          written mainly in C++.
          As a class library, and among other thing, GAGS includes:
          
          + A chromosome hierarchy with variable length chromosomes.
            Genetic operators: 2-point crossover, uniform crossover,
            bit-flip mutation, transposition (gene interchange between 2
            parts of the chromosome), and variable-length operators:
            duplication, elimination, and random addition.
          + Population level operators include steady state, roulette
            wheel and tournament selection.
          + Gnuplot wrapper: turns gnuplot into a iostreams-like class.
          + Easy sample file loading and configuration file parsing.
            
          As an application generator (written in PERL), you only need to
          supply it with an ANSI-C or C++ fitness function, and it
          creates a C++ program that uses the above library to 90%
          capacity, compiles it, and runs it, saving results and
          presenting fitness thru gnuplot.
          
   GAlib: Matthew's Genetic Algorithms Library
          Web Site: [117]lancet.mit.edu/ga/
          FTP site: [118]lancet.mit.edu/pub/ga/
          Register GAlib at: [119]http://lancet.mit.edu/ga/Register.html
          GAlib contains a set of C++ genetic algorithm objects. The
          library includes tools for using genetic algorithms to do
          optimization in any C++ program using any representation and
          genetic operators. The documentation includes an extensive
          overview of how to implement a genetic algorithm as well as
          examples illustrating customizations to the GAlib classes.
          
   GALOPPS
          Web site: [120]GARAGe.cps.msu.edu/software/software-index.html
          FTP site: [121]garage.cps.msu.edu/pub/GA/galopps/
          GALOPPS is a flexible, generic GA, in 'C'. It was based upon
          Goldberg's Simple Genetic Algorithm (SGA) architecture, in
          order to make it easier for users to learn to use and extend.
          
          GALOPPS extends the SGA capabilities several fold:
          
          + (optional) A new Graphical User Interface, based on TCL/TK,
            for Unix users, allowing easy running of GALOPPS 3.2 (single
            or multiple subpopulations) on one or more processors. GUI
            writes/reads "standard" GALOPPS input and master files, and
            displays graphical output (during or after run) of
            user-selected variables.
          + 5 selection methods: roulette wheel, stochastic remainder
            sampling, tournament selection, stochastic universal
            sampling, linear-ranking-then-SUS.
          + Random or superuniform initialization of "ordinary"
            (non-permutation) binary or non-binary chromosomes; random
            initialization of permutation-based chromosomes; or
            user-supplied initialization of arbitrary types of
            chromosomes.
          + Binary or non-binary alphabetic fields on value-based
            chromosomes, including different user-definable field sizes.
          + 3 crossovers for value-based representations: 1-pt, 2-pt, and
            uniform, all of which operate at field boundaries if a
            non-binary alphabet is used.
          + 4 crossovers for order-based reps: PMX, order-based, uniform
            order-based, and cycle.
          + 4 mutations: fast bitwise, multiple-field, swap and random
            sublist scramble.
          + Fitness scaling: linear scaling, Boltzmann scaling, sigma
            truncation, window scaling, ranking.
          + Plus a whole lot more....
            
   GAS [New]
          Web site: [122]starship.skyport.net/crew/gandalf
          FTP site: [123]ftp.coe.uga.edu/users/jae/ai
          GAS means "Genetic Algorithms Stuff". GAS is freeware.
          Purpose of GAS is to explore and exploit artificial evolutions.
          Primary implementation language of GAS is Python. The GAS
          software package is meant to be a Python framework for applying
          genetic algorithms. It contains an example application where it
          is tried to breed Python program strings. This special problem
          falls into the category of Genetic Programming (GP), and/or
          Automatic Programming. Nevertheless, GAS tries to be useful for
          other applications of Genetic Algorithms as well.
          
   GECO
          FTP site: [124]ftp://ftp.aic.nrl.navy.mil/pub/galist/src/
          GECO (Genetic Evolution through Combination of Objects), an
          extendible object-oriented tool-box for constructing genetic
          algorithms (in Lisp). It provides a set of extensible classes
          and methods designed for generality. Some simple examples are
          also provided to illustrate the intended use.
          
   GPdata
          FTP site:
          [125]ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/gp-code/
          Documentation (GPdata-icga-95.ps):
          [126]cs.ucl.ac.uk/genetic/papers/
          GPdata-3.0.tar.gz (C++) contains a version of Andy Singleton's
          GP-Quick version 2.1 which has been extensively altered to
          support:
          
          + Indexed memory operation (cf. teller)
          + multi tree programs
          + Adfs
          + parameter changes without recompilation
          + populations partitioned into demes
          + (A version of) pareto fitness
            
          This ftp site also contains a small C++ program (ntrees.cc) to
          calculate the number of different there are of a given length
          and given function and terminal set.
          
   gpjpp Genetic Programming in Java
          Web site: [127]www.turbopower.com/~kimk/gpjpp.asp
          gpjpp is a Java package I wrote for doing research in genetic
          programming. It is a port of the gpc++ kernel written by Adam
          Fraser and Thomas Weinbrenner. Included in the package are four
          of Koza's standard examples: the artificial ant, the hopping
          lawnmower, symbolic regression, and the boolean multiplexer.
          Here is a partial list of its features:
          
          + graphic output of expression trees
          + efficient diversity checking
          + Koza's greedy over-selection option for large populations
          + extensible GPRun class that encapsulates most details of a
            genetic programming test
          + more robust and efficient streaming code, with automatic
            checkpoint and restart built into the GPRun class
          + an explicit complexity limit that can be set on each GP
          + additional configuration variables to allow more testing
            without recompilation
          + support for automatically defined functions (ADFs)
          + tournament and fitness proportionate selection
          + demetic grouping
          + optional steady state population
          + subtree crossover
          + swap and shrink mutation
            
   GP Kernel
          Web site:
          [128]www.emk.e-technik.th-darmstadt.de/~thomasw/gp.html
          The GP kernel is a C++ class library that can be used to apply
          genetic programming techniques to all kinds of problems. The
          library defines a class hierarchy. An integral component is the
          ability to produce automatically defined functions as found in
          Koza's "Genetic Programming II".Technical documentation
          (postscript format) is included. There is also a short
          introduction into genetic programming.
          
          Functionality includes; Automatically defined functions (ADFs),
          tournament and fitness proportionate selection, demetic
          grouping, optional steady state genetic programming kernel,
          subtree crossover, swap and shrink mutation, a way of changing
          every parameter of the system without recompilation, capacity
          for multiple populations, loading and saving of populations and
          genetic programs, standard random number generator, internal
          parameter checks.
          
   lil-gp
          Web site: [129]isl.msu.edu/GA/software/lil-gp/index.html
          FTP site: [130]isl.cps.msu.edu/pub/GA/lilgp/
          
   patched lil-gp * [New]
          Web site: [131]www.cs.umd.edu/users/seanl/patched-gp
          lil-gp is a generic 'C' genetic programming tool. It was
          written with a number of goals in mind: speed, ease of use and
          support for a number of options including:
          
          + Generic 'C' program that runs on UNIX workstations
          + Support for multiple population experiments, using arbitrary
            and user settable topologies for exchange, for a single
            processor (i.e., you can do multiple population gp
            experiments on your PC).
          + lil-gp manipulates trees of function pointers which are
            allocated in single, large memory blocks for speed and to
            avoid swapping.
            
          * The patched lil-gp kernel is strongly-typed, with
          modifications on multithreading, fixes to some *serious* bugs
          in lilgp, coevolution, and other tweaks and features.
          
   PGAPack Parallel Genetic Algorithm Library
          Web site: [132]www.mcs.anl.gov/home/levine/PGAPACK/index.html
          FTP site: [133]ftp.mcs.anl.gov/pub/pgapack/
          PGAPack is a general-purpose, data-structure-neutral, parallel
          genetic algorithm library. It is intended to provide most
          capabilities desired in a genetic algorithm library, in an
          integrated, seamless, and portable manner. Key features are in
          PGAPack V1.0 include:
          
          + Callable from Fortran or C.
          + Runs on uniprocessors, parallel computers, and workstation
            networks.
          + Binary-, integer-, real-, and character-valued native data
            types.
          + Full extensibility to support custom operators and new data
            types.
          + Easy-to-use interface for novice and application users.
          + Multiple levels of access for expert users.
          + Parameterized population replacement.
          + Multiple crossover, mutation, and selection operators.
          + Easy integration of hill-climbing heuristics.
          + Extensive debugging facilities.
          + Large set of example problems.
          + Detailed users guide.
            
   Sugal
          Web site: [134]www.trajan-software.demon.co.uk/sugal.htm
          Sugal [soo-gall] is the SUnderland Genetic ALgorithm system.
          The aim of Sugal is to support research and implementation in
          Genetic Algorithms on a common software platform. As such,
          Sugal supports a large number of variants of Genetic
          Algorithms, and has extensive features to support customization
          and extension.
          
  EC software kits/applications
  
   These are various applications, software kits, etc. meant for research
   in the field of evolutionary computing. Their ease of use will vary,
   as they were designed to meet some particular research interest more
   than as an easy to use commercial package.
   
   ADATE(Automatic Design of Algorithms Through Evolution)
          Web site: [135]www-ia.hiof.no/~rolando/adate_intro.html
          ADATE is a system for automatic programming i.e., inductive
          inference of algorithms, which may be the best way to develop
          artificial and general intelligence.
          
          The ADATE system can automatically generate non-trivial and
          novel algorithms. Algorithms are generated through large scale
          combinatorial search that employs sophisticated program
          transformations and heuristics. The ADATE system is
          particularly good at synthesizing symbolic, functional programs
          and has several unique qualities.
          
   esep & xesep [New]
          Web site(esep): [136]www.iit.edu/~linjinl/esep.html Web
          site(xesep): [137]www.iit.edu/~linjinl/xesep.html
          This is a new scheduler, called Evolution Scheduler, based on
          Genetic Algorithms and Evolutionary Programming. It lives with
          original Linux priority scheduler.This means you don't have to
          reboot to change the scheduling policy. You may simply use the
          manager program esep to switch between them at any time, and
          esep itself is an all-in-one for scheduling status, commands,
          and administration. We didn't intend to remove the original
          priority scheduler; instead, at least, esep provides you with
          another choice to use a more intelligent scheduler, which
          carries out natural competition in an easy and effective way.
          
          Xesep is a graphical user interface to the esep (Evolution
          Scheduling and Evolving Processes). It's intended to show users
          how to start, play, and feel the Evolution Scheduling and
          Evolving Processes, including sub-programs to display system
          status, evolving process status, queue status, and evolution
          scheduling status periodically in as small as one mini-second.
          
   FSM-Evolver [New]
          Web site: [138]pages.prodigy.net/czarneckid
          A Java (jdk-v1.0.2+) code library that is used to evolve finite
          state machines. The problem included in the package is the
          Artificial Ant problem. You should be able to compile the .java
          files and then run: java ArtificialAnt.
          
   GPsys [New]
          Web site: [139]www.cs.ucl.ac.uk/staff/A.Qureshi/gpsys.html
          GPsys (pronounced gipsys) is a Java (requires Java 1.1 or
          later) based Genetic Programming system developed by Adil
          Qureshi. The software includes documentation, source and
          executables.
          
          Feature Summary:
          
          + Steady State engine
          + ADF support
          + Strongly Typed
            
          + supports generic functions and terminals
          + has many built-in primitives
          + includes indexed memory
            
     Save/Load feature
          
          + can save/load current generation to/from a file
          + data stored in GZIP compression format to minimise disk
            requirements
          + uses serialisable objects for efficiency
            
     Fully Documented
          
     Example Problems
          
          + Lawnmower (including GUI viewer)
          + Symbolic Regression
            
     Totally Parameterised
          
     Fully Object Oriented and Extensible
          
     High Performance
          
     Memory Efficient
          
Alife

   Alife takes yet another approach to exploring the mysteries of
   intelligence. It has many aspects similar to EC and Connectionism, but
   takes these ideas and gives them a meta-level twist. Alife emphasizes
   the development of intelligence through emergent behavior of complex
   adaptive systems. Alife stresses the social or group based aspects of
   intelligence. It seeks to understand life and survival. By studying
   the behaviors of groups of 'beings' Alife seeks to discover the way
   intelligence or higher order activity emerges from seemingly simple
   individuals. Cellular Automata and Conway's Game of Life are probably
   the most commonly known applications of this field.
   
  Alife class/code libraries
  
   These are libraries of code or classes for use in programming within
   the artificial life field. They are not meant as stand alone
   applications, but rather as tools for building your own applications.
   
   John von Neumann Universal Constructor
          Web site: [140]alife.santafe.edu/alife/software/jvn.html
          FTP site: [141]alife.santafe.edu/pub/SOFTWARE/jvn/
          The universal constructor of John von Neumann is an extension
          of the logical concept of universal computing machine. In the
          cellular environment proposed by von Neumann both computing and
          constructive universality can be achieved. Von Neumann proved
          that in his cellular lattice both a Turing machine and a
          machine capable of producing any other cell assembly, when fed
          with a suitable program, can be embedded. He called the latter
          machine a "universal constructor" and showed that, when
          provided with a program containing its own description, this is
          capable of self-reproducing.
          
   Swarm
          Web site: [142]www.santafe.edu/projects/swarm
          FTP site: [143]ftp.santafe.edu/pub/swarm
          The swarm Alife simulation kit. Swarm is a simulation
          environment which facilitates development and experimentation
          with simulations involving a large number of agents behaving
          and interacting within a dynamic environment. It consists of a
          collection of classes and libraries written in Objective-C and
          allows great flexibility in creating simulations and analyzing
          their results. It comes with three demos and good
          documentation.
          
          Swarm 1.0 is out. It requires libtclobjc and BLT 2.1 (both
          available at the swarm site).
          
  Alife software kits, applications, etc.
  
   These are various applications, software kits, etc. meant for research
   in the field of artificial life. Their ease of use will vary, as they
   were designed to meet some particular research interest more than as
   an easy to use commercial package.
   
   BugsX
          FTP site:
          [144]ftp.Germany.EU.net/pub/research/softcomp/Alife/packages/bu
          gsx/ 
          Display and evolve biomorphs. It is a program which draws the
          biomorphs based on parametric plots of Fourier sine and cosine
          series and let's you play with them using the genetic
          algorithm.
          
   The Cellular Automata Simulation System
          Web site: [145]www.cs.runet.edu/~dana/ca/cellular.html
          The system consists of a compiler for the Cellang cellular
          automata programming language, along with the corresponding
          documentation, viewer, and various tools. Cellang has been
          undergoing refinement for the last several years (1991-1995),
          with corresponding upgrades to the compiler. Postscript
          versions of the tutorial and language reference manual are
          available for those wanting more detailed information. The most
          important distinguishing features of Cellang, include support
          for:
          
          + any number of dimensions;
          + compile time specification of each dimensions size; cell
            neighborhoods of any size (though bounded at compile time)
            and shape;
          + positional and time dependent neighborhoods;
          + associating multiple values (fields), including arrays, with
            each cell;
          + associating a potentially unbounded number of mobile agents [
            Agents are mobile entities based on a mechanism of the same
            name in the Creatures system, developed by Ian Stephenson
            (ian@ohm.york.ac.uk).] with each cell; and
          + local interactions only, since it is impossible to construct
            automata that contain any global control or references to
            global variables.
            
   dblife & dblifelib
          FTP site:
          [146]ftp.cc.gatech.edu/ac121/linux/games/amusements/life/
          dblife: Sources for a fancy Game of Life program for X11 (and
          curses). It is not meant to be incredibly fast (use xlife for
          that:-). But it IS meant to allow the easy editing and viewing
          of Life objects and has some powerful features. The related
          dblifelib package is a library of Life objects to use with the
          program.
          
          dblifelib: This is a library of interesting Life objects,
          including oscillators, spaceships, puffers, and other weird
          things. The related dblife package contains a Life program
          which can read the objects in the Library.
          
   Drone
          Web site: [147]pscs.physics.lsa.umich.edu/Software/Drone/
          Drone is a tool for automatically running batch jobs of a
          simulation program. It allows sweeps over arbitrary sets of
          parameters, as well as multiple runs for each parameter set,
          with a separate random seed for each run. The runs may be
          executed either on a single computer or over the Internet on a
          set of remote hosts. Drone is written in Expect (an extension
          to the Tcl scripting language) and runs under Unix. It was
          originally designed for use with the Swarm agent-based
          simulation framework, but Drone can be used with any simulation
          program that reads parameters from the command line or from an
          input file.
          
   EcoLab [New]
          Web site: [148]parallel.acsu.unsw.edu.au/rks/ecolab.html
          EcoLab is a system that implements an abstract ecology model.
          It is written as a set of Tcl/Tk commands so that the model
          parameters can easily be changed on the fly by means of editing
          a script. The model itself is written in C++.
          
   Game Of Life (GOL) [New]
          Web site: [149]www.arrakeen.demon.co.uk/downloads.html
          FTP site: [150]sunsite.unc.edu/pub/Linux/science/ai/life
          GOL is a simulator for conway's game of life (a simple cellular
          automata), and other simple rule sets. The emphasis here is on
          speed and scale, in other words you can setup large and fast
          simulations.
          
   LEE
          Web site: [151]www-cse.ucsd.edu/users/fil/lee/lee.html
          FTP site: [152]cs.ucsd.edu/pub/LEE/
          LEE (Latent Energy Environments) is both an Alife model and a
          software tool to be used for simulations within the framework
          of that model. We hope that LEE will help understand a broad
          range of issues in theoretical, behavioral, and evolutionary
          biology. The LEE tool described here consists of approximately
          7,000 lines of C code and runs in both Unix and Macintosh
          platforms.
          
   Net-Life & ZooLife
          Web site:[153]www.geocities.com/SiliconValley/Heights/1051**
          FTP site: [154]ftp.coe.uga.edu/users/jae/alife/
          *(netlife-2.0.tar.gz contains both Net-Life and ZooLife)
          Net-Life is a simulation of artificial-life, with neural
          "brains" generated via slightly random techniques. Net-Life
          uses artificial neural nets and evolutionary algorithms to
          breed artificial organisms that are similar to single cell
          organisms. Net-life uses asexual reproduction of its fittest
          individuals with a chance of mutation after each round to
          eventually evolve successful life-forms.
          
          ZooLife is a simulation of artificial-life. ZooLife uses
          probabilistic methods and evolutionary algorithms to breed
          artificial organisms that are similar to plant/animal zoo
          organisms. ZooLife uses asexual reproduction with a chance of
          mutation.
          
   Primordial Soup
          Web site: [155]alife.santafe.edu/alife/software/psoup.html
          Primordial Soup is an artificial life program. Organisms in the
          form of computer software loops live in a shared memory space
          (the "soup") and self-reproduce. The organisms mutate and
          evolve, behaving in accordance with the principles of Darwinian
          evolution.
          
          The program may be started with one or more organisms seeding
          the soup. Alternatively, the system may be started "sterile",
          with no organisms present. Spontaneous generation of
          self-reproducing organisms has been observed after runs as
          short as 15 minutes.
          
   Tierra
          Web site: [156]www.hip.atr.co.jp/~ray/tierra/tierra.html
          FTP site: [157]alife.santafe.edu/pub/SOFTWARE/Tierra/
          Alternate FTP site:
          [158]ftp.cc.gatech.edu/ac121/linux/science/biology/
          Tierra's written in the C programming language. This source
          code creates a virtual computer and its operating system, whose
          architecture has been designed in such a way that the
          executable machine codes are evolvable. This means that the
          machine code can be mutated (by flipping bits at random) or
          recombined (by swapping segments of code between algorithms),
          and the resulting code remains functional enough of the time
          for natural (or presumably artificial) selection to be able to
          improve the code over time.
          
   TIN
          FTP site: [159]ftp.coe.uga.edu/users/jae/alife/
          This program simulates primitive life-forms, equipped with some
          basic instincts and abilities, in a 2D environment consisting
          of cells. By mutation new generations can prove their success,
          and thus passing on "good family values".
          
          The brain of a TIN can be seen as a collection of processes,
          each representing drives or impulses to behave a certain way,
          depending on the state/perception of the environment ( e.g.
          presence of food, walls, neighbors, scent traces) These
          behavior process currently are : eating, moving, mating,
          relaxing, tracing others, gathering food and killing. The
          process with the highest impulse value takes control, or in
          other words: the tin will act according to its most urgent
          need.
          
   XLIFE
          FTP site:
          [160]ftp.cc.gatech.edu/ac121/linux/games/amusements/life/
          This program will evolve patterns for John Horton Conway's game
          of Life. It will also handle general cellular automata with the
          orthogonal neighborhood and up to 8 states (it's possible to
          recompile for more states, but very expensive in memory).
          Transition rules and sample patterns are provided for the
          8-state automaton of E. F. Codd, the Wireworld automaton, and a
          whole class of `Prisoner's Dilemma' games.
          
Autonomous Agents

   Also known as intelligent software agents or just agents, this area of
   AI research deals with simple applications of small programs that aid
   the user in his/her work. They can be mobile (able to stop their
   execution on one machine and resume it on another) or static (live in
   one machine). They are usually specific to the task (and therefore
   fairly simple) and meant to help the user much as an assistant would.
   The most popular (ie. widely known) use of this type of application to
   date are the web robots that many of the indexing engines (eg.
   webcrawler) use.
   
   AgentK
          FTP site: [161]ftp.csd.abdn.ac.uk/pub/wdavies/agentk
          This package synthesizes two well-known agent paradigms:
          Agent-Oriented Programming, Shoham (1990), and the Knowledge
          Query & Manipulation Language, Finin (1993). The initial
          implementation of AOP, Agent-0, is a simple language for
          specifying agent behaviour. KQML provides a standard language
          for inter-agent communication. Our integration (which we have
          called Agent-K) demonstrates that Agent-0 and KQML are highly
          compatible. Agent-K provides the possibility of inter-operable
          (or open) software agents, that can communicate via KQML and
          which are programmed using the AOP approach.
          
   Agent, the Perl5 Module
          FTP site:
          [162]ftp.hawk.igs.net/pub/users/jduncan/modules/Agent/
          The Agent is a prototype for an Information Agent system. It is
          both platform and language independent, as it stores contained
          information in simple packed strings. It can be packed and
          shipped across any network with any format, as it freezes
          itself in its current state.
          
   AGENT TCL
          Web site: [163]www.cs.dartmouth.edu/~agent/
          FTP site: [164]ftp.cs.dartmouth.edu/pub/agents/
          A transportable agent is a program that can migrate from
          machine to machine in a heterogeneous network. The program
          chooses when and where to migrate. It can suspend its execution
          at an arbitrary point, transport to another machine and resume
          execution on the new machine. For example, an agent carrying a
          mail message migrates first to a router and then to the
          recipient's mailbox. The agent can perform arbitrarily complex
          processing at each machine in order to ensure that the message
          reaches the intended recipient.
          
   Aglets Workbench
          Web site: [165]www.trl.ibm.co.jp/aglets/
          An aglet is a Java object that can move from one host on the
          Internet to another. That is, an aglet that executes on one
          host can suddenly halt execution, dispatch to a remote host,
          and resume execution there. When the aglet moves, it takes
          along its program code as well as its state (data). A built-in
          security mechanism makes it safe for a computer to host
          untrusted aglets. The Java Aglet API (J-AAPI) is a proposed
          public standard for interfacing aglets and their environment.
          J-AAPI contains methods for initializing an aglet, message
          handling, and dispatching, retracting, deactivating/activating,
          cloning, and disposing of the aglet. J-AAPI is simple,
          flexible, and stable. Application developers can write
          platform-independent aglets and expect them to run on any host
          that supports J-AAPI.
          
   Ara
          Web site: [166]www.uni-kl.de/AG-Nehmer/Ara/
          Ara is a platform for the portable and secure execution of
          mobile agents in heterogeneous networks. Mobile agents in this
          sense are programs with the ability to change their host
          machine during execution while preserving their internal state.
          This enables them to handle interactions locally which
          otherwise had to be performed remotely. Ara's specific aim in
          comparison to similar platforms is to provide full mobile agent
          functionality while retaining as much as possible of
          established programming models and languages.
          
   JAFMAS [New]
          Web site: [167]www.ececs.uc.edu/~abaker/JAFMAS
          JAFMAS provides a framework to guide the coherent development
          of multiagent systems along with a set of classes for agent
          deployment in Java. The framework is intended to help beginning
          and expert developers structure their ideas into concrete agent
          applications. It directs development from a speech-act
          perspective and supports multicast and directed communication,
          KQML or other speech-act performatives and analysis of
          multiagent system coherency and consistency.
          
          Only four of the provided Java classes must be extended for any
          application. Provided examples of the N-Queens and Supply Chain
          Integration use only 567 and 1276 lines of additional code
          respectively for implementation.
          
   JATLite
          Web site: [168]java.stanford.edu/java_agent/html/
          JATLite is providing a set of java packages which makes easy to
          build multi-agent systems using Java. JATLite provides only
          light-weight, small set of packages so that the developers can
          handle all the packages with little efforts. For flexibility
          JATLite provides four different layers from abstract to Router
          implementation. A user can access any layer we are providing.
          Each layer has a different set of assumptions. The user can
          choose an appropriate layer according to the assumptions on the
          layer and user's application. The introduction page contains
          JATLite features and the set of assumptions for each layer.
          
   Java(tm) Agent Template
          Web site: [169]cdr.stanford.edu/ABE/JavaAgent.html
          The JAT provides a fully functional template, written entirely
          in the Java language, for constructing software agents which
          communicate peer-to-peer with a community of other agents
          distributed over the Internet. Although portions of the code
          which define each agent are portable, JAT agents are not
          migratory but rather have a static existence on a single host.
          This behavior is in contrast to many other "agent"
          technologies. (However, using the Java RMI, JAT agents could
          dynamically migrate to a foreign host via an agent resident on
          that host). Currently, all agent messages use KQML as a
          top-level protocol or message wrapper. The JAT includes
          functionality for dynamically exchanging "Resources", which can
          include Java classes (e.g. new languages and interpreters,
          remote services, etc.), data files and information inlined into
          the KQML messages.
          
   Java-To-Go
          Web site:
          [170]ptolemy.eecs.berkeley.edu/dgm/javatools/java-to-go/
          Java-To-Go is an experimental infrastructure that assists in
          the development and experimentation of mobile agents and
          agent-based applications for itinerative computing (itinerative
          computing: the set of applications that requires site-to-site
          computations. The main emphasis here is on a easy-to-setup
          environment that promotes quick experimentation on mobile
          agents.
          
   Kafka [New]
          Web site: [171]www.fujitsu.co.jp/hypertext/free/kafka/
          Kafka is yet another agent library designed for constructing
          multi-agent based distributed applications. Kafka is a
          flexible, extendable, and easy-to-use java class library for
          programmers who are familiar with distributed programming. It
          is based on Java's RMI and has the following added features:
          
        Runtime Reflection:
                Agents can modify their behaviour (program codes) at
                runtime. The behaviour of the agent is represented by an
                abstract class Action. It is useful for remote
                maintenance or installation services.
                
        Remote Evaluation:
                Agents can receive and evaluate program codes (classes)
                with or without the serialized object. Remote evaluation
                is a fundamental function of a mobile agent and is
                thought to be a push model of service delivery.
                
        Distributed Name Service:
                Agents have any number of logical names that don't
                contain the host name. These names can be managed by the
                distributed directories.
                
        Customizable security policy
                a very flexible, customizable, 3-layered security model
                is implemented in Kafka.
                
        100% Java and RMI compatible:
                Kafka is written completely in Java. Agent is a Java RMI
                server object itself. So, agents can directly communicate
                with other RMI objects.
                
   Khepera Simulator
          Web site: [172]diwww.epfl.ch/lami/team/michel/khep-sim/
          Khepera Simulator is a public domain software package written
          by [173]Olivier MICHEL during the preparation of his Ph.D.
          thesis, at the Laboratoire I3S, URA 1376 of CNRS and University
          of Nice-Sophia Antipolis, France. It allows to write your own
          controller for the mobile robot Khepera using C or C++
          languages, to test them in a simulated environment and features
          a nice colorful X11 graphical interface. Moreover, if you own a
          Khepera robot, it can drive the real robot using the same
          control algorithm. It is mainly oriented toward to researchers
          studying autonomous agents.
          
   Mole
          Web site:
          [174]www.informatik.uni-stuttgart.de/ipvr/vs/projekte/mole.html
          Mole is an agent system supporting mobile agents programmed in
          Java. Mole's agents consist of a cluster of objects, which have
          no references to the outside, and as a whole work on tasks
          given by the user or another agent. They have the ability to
          roam a network of "locations" autonomously. These "locations"
          are an abstraction of real, existing nodes in the underlying
          network. They can use location-specific resources by
          communicating with dedicated agents representing these
          services. Agents are able to use services provided by other
          agents and to provide services as well.
          
   Odyssey
          Web site: [175]www.genmagic.com/agents/
          Odyssey is General Magic's initial implementation of mobile
          agents in 100% pure Java. The Odyssey class libraries enable
          you to develop your own mobile agent applications. Use mobile
          agents to access data, make decisions and notify users. Your
          agent-enabled applications may also take full advantage of the
          Java platform and use other third party libraries, for example,
          to access remote CORBA objects or to access relational
          databases using JDBC. To see how it's done, take a look at the
          sample applications included as part of the Odyssey download.
          
   Penguin!
          FTP site:
          [176]www.perl.org/CPAN/modules/by-category/23_Miscellaneous_Mod
          ules/Penguin/FSG/
          Penguin is a Perl 5 module. It provides you with a set of
          functions which allow you to:
          
          + send encrypted, digitally signed Perl code to a remote
            machine to be executed.
          + receive code and, depending on who signed it, execute it in
            an arbitrarily secure, limited compartment.
            
          The combination of these functions enable direct Perl coding of
          algorithms to handle safe internet commerce, mobile
          information-gathering agents, "live content" web browser helper
          apps, distributed load-balanced computation, remote software
          update, distance machine administration, content-based
          information propagation, Internet-wide shared-data
          applications, network application builders, and so on.
          
   SimRobot
          Web site: [177]www.informatik.uni-bremen.de/~simrobot/
          FTP site: [178]ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/
          SimRobot is a program for simulation of sensor based robots in
          a 3D environment. It is written in C++, runs under UNIX and X11
          and needs the graphics toolkit XView.
          
          + Simulation of robot kinematics
          + Hierarchically built scene definition via a simple definition
            language
          + Various sensors built in: camera, facette eye, distance
            measurement, light sensor, etc.
          + Objects defined as polyeders
          + Emitter abstractly defined; can be interpreted e.g. as light
            or sound
          + Camera images computed according to the raytracing or
            Z-buffer algorithms known from computer graphics
          + Specific sensor/motor software interface for communicating
            with the simulation
          + Texture mapping onto the object surfaces: bitmaps in various
            formats
          + Comprehensive visualization of the scene: wire frame w/o
            hidden lines, sensor and actor values
          + Interactive as well as batch driven control of the agents and
            operation in the environment
          + Collision detection
          + Extendability with user defined object types
          + Possible socket communication to e.g. the Khoros image
            processing software
            
   TclRobots
          FTP site:
          [179]ftp.neosoft.com/pub/tcl/sorted/games/tclrobots-2.0/
          Redhat Patch:
          [180]ftp.coe.uga.edu/users/jae/ai/tclrobots-redhat.patch
          RPMs: [181]ftp://ftp.redhat.com/contrib/
          TclRobots is a programming game, similar to 'Core War'. To play
          TclRobots, you must write a Tcl program that controls a robot.
          The robot's mission is to survive a battle with other robots.
          Two, three, or four robots compete during a battle, each
          running different programs (or possibly the same program in
          different robots.) Each robot is equipped with a scanner,
          cannon, drive mechanism. A single match continues until one
          robot is left running. Robots may compete individually, or
          combine in a team oriented battle. A tournament can be run with
          any number of robot programs, each robot playing every other in
          a round-robin fashion, one-on-one. A battle simulator is
          available to help debug robot programs.
          
          The TclRobots program provides a physical environment, imposing
          certain game parameters to which all robots must adhere.
          TclRobots also provides a view on a battle, and a controlling
          user interface. TclRobots requirements: a wish interpreter
          built from Tcl 7.4 and Tk 4.0.
          
   The Tocoma Project
          Web site: [182]www.cs.uit.no/DOS/Tacoma/index.html
          An agent is a process that may migrate through a computer
          network in order to satisfy requests made by clients. Agents
          are an attractive way to describe network-wide computations.
          
          The TACOMA project focuses on operating system support for
          agents and how agents can be used to solve problems
          traditionally addressed by operating systems. We have
          implemented a series of prototype systems to support agents.
          
          TACOMA Version 1.2 is based on UNIX and TCP. The system
          supports agents written in C, Tcl/Tk, Perl, Python, and Scheme
          (Elk). It is implemented in C. This TACOMA version has been in
          public domain since April 1996.
          
          We are currently focusing on heterogeneity, fault-tolerance,
          security and management issues. Also, several TACOMA
          applications are under construction. We implemented StormCast
          4.0, a wide-area network weather monitoring system accessible
          over the internet, using TACOMA and Java. We are now in the
          process of evaluating this application, and plan to build a new
          StormCast version to be completed by June 1997.
          
   Virtual Secretary Project (ViSe) (Tcl/Tk) [New]
          Web site: [183]www.cs.uit.no/DOS/Virt_Sec
          The motivation of the Virtual Secretary project is to construct
          user-model-based intelligent software agents, which could in
          most cases replace human for secretarial tasks, based on modern
          mobile computing and computer network. The project includes two
          different phases: the first phase (ViSe1) focuses on
          information filtering and process migration, its goal is to
          create a secure environment for software agents using the
          concept of user models; the second phase (ViSe2) concentrates
          on agents' intelligent and efficient cooperation in a
          distributed environment, its goal is to construct cooperative
          agents for achieving high intelligence. (Implemented in
          Tcl/TclX/Tix/Tk)
          
   VWORLD
          Web site: [184]www.ai.uga.edu/~jae/projects.html#vworld
          Vworld is a simulated environment for research with autonomous
          agents written in prolog. It is currently in something of an
          beta stage. It works well with SWI-prolog, but should work with
          Quitnus-prolog with only a few changes. It is being designed to
          serve as an educational tool for class projects dealing with
          prolog and autonomous agents. It comes with three demo worlds
          or environments, along with sample agents for them.
          There are two versions now. One written for SWI-prolog and one
          written for LPA-prolog. Documentation is roughly done (with a
          student/professor framework in mind), and a graphical interface
          is planned.
          
   WebMate
          Web site: [185]www.cs.cmu.edu/~softagents/webmate/
          WebMate is a personal agent for World-Wide Web browsing and
          searching. It accompanies you when you travel on the internet
          and provides you what you want.
          Features include:
          
          + Searching enhancement, including parallel search, searching
            keywords refinement using our relevant keywords extraction
            technology, relevant feedback, etc.
          + Browsing assistant, including learning your current
            interesting, recommending you new URLs according to your
            profile and selected resources, monitoring bookmarks of
            Netscape or IE, sending the current browsing page to your
            friends, etc.
          + Offline browsing, including downloading the following pages
            from the current page for offline browsing.
          + Filtering HTTP header, including recording http header and
            all the transactions between your browser and WWW servers,
            etc.
          + Checking the HTML page to find the errors or dead links, etc.
          + Programming in Java, independent of operating system, runing
            in multi-thread.
            
AI & Alife related newsgroups

   These newsgroups are not Linux specific. But they are good resources
   for anyone working in artificial intelligence or artificial life. If
   you can't access these newsgroups, many of their FAQs are available
   at:
   [186]http://www.cis.ohio-state.edu/hypertext/faq/bngusenet/comp/ai/top
   .html
     * [187]comp.ai
     * [188]comp.ai.edu
     * [189]comp.ai.genetic
     * [190]comp.ai.neural-nets
     * [191]comp.ai.vision
     * [192]comp.ai.fuzzy
     * [193]comp.ai.games
     * [194]comp.ai.jair.announce
     * [195]comp.ai.jair.papers
     * [196]comp.ai.nat-lang
     * [197]comp.ai.nlang-know-rep
     * [198]comp.ai.philosophy
     * [199]comp.ai.shells
     * [200]comp.ai.alife
     * [201]comp.ai.doc-analysis.misc
     * [202]comp.ai.doc-analysis.ocr
     * [203]comp.lang.prolog
     * [204]comp.lang.lisp
     * [205]alt.irc.bots
       
AI & Alife resource links

   These are a few of the many AI and Alife sites out there. These sites
   are good places to start hunting for more information or for finding
   software. I'll be adding more links to this list soon, as well as
   organizing it better. These links are not Linux specific, but I wanted
   to include them to provide a jump off point to the huge amount of info
   related to these topics located on the web.
   
  AI/Alife Archives, Research, Bibliographies, etc.
  
   All Catagories
       
     [206]SAL.KachinaTech.COM/Z/3/-Scientific Applications for Linux's AI
       page
     [207]www.cs.cmu.edu/Web/Groups/AI/html/repository.html-CMU
       Artificial Intelligence Repository
     [208]liinwww.ira.uka.de/bibliography/Ai/index.html -Bibliographies
       on Artificial Intelligence [New]
       
   Traditional AI
     [209]www.mcs.net/~jorn/html/ai.html-Outsider's Guide to AI
     [210]www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/clt
       l/clm/clm.html-Common Lisp Book
     [211]www.elwoodcorp.com/alu/table/contents.htm-The Association of
       Lisp Users
     [212]www.cs.indiana.edu/scheme-repository/home.html-Scheme
       repository
     [213]www.aic.nrl.navy.mil/-Navy Center for Applied Research in
       Artificial Intelligence
     [214]intranet.ca/~sshah/waste/waste.html-WASTE (AI Contest)
     [215]www.cs.washington.edu/research/jair/home.html-Journal of
       Artificial Intelligence Research
     [216]www.cs.ucl.ac.uk/misc/ai/-University of London's AI Resource
       Page
     [217]www.cris.com/~swoodcoc/ai.html -Artificial Intelligence in
       Games
     [218]strips.lboro.ac.uk/bib/ -An Online Bibliography on Planning and
       Scheduling
       
   Connectionism
     [219]www.neuronet.ph.kcl.ac.uk/neuronet/software/software.html-NEuro
       Net - ANN software
       
   Evolutionary Computing
     [220]ftp://ftp.mad-scientist.com/pub/genetic-programming/-John
       Koza's Genetic Programming archive.
     [221]www.cpsc.ucalgary.ca/~jacob/Evolvica/ -Tutorial: Evolutionary
       Algorithms in Action
     [222]alife.santafe.edu/~joke/encore/-ENCORE-The Hitch-Hikers Guide
       to Evolutionary Computation
     [223]gal4.ge.uiuc.edu/illigal.home.html-IlliGAL Home Page (GA's)
     [224]isl.msu.edu/GA/-MSU GARAGe Home Page (GA's)
     [225]www.aracnet.com/~wwir/NovaGenetica/-Nova Genetica (GA's)
       
   Artifical Life
     [226]alife.santafe.edu/~joke/zooland/-ZooLand Artificial Life
       Resources
     [227]alife.santafe.edu-Santafe's Alife page
     [228]www.krl.caltech.edu/~brown/alife/-Alife FAQ
     [229]www.cogs.susx.ac.uk/users/ezequiel/alife-page/alife.html-ALife
       Bibliography
     [230]complex.csu.edu.au/complex/-Complex Systems Information Network
     [231]www.geneticprogramming.com/-The Genetic Programming Notebook
     [232]gracco.irmkant.rm.cnr.it/luigi/lupa_algames.html-The Artificial
       Life Games Homepage
     [233]www.krl.caltech.edu/~charles/alife-game/-Project: Von Neumann
       
   Agents & Bots
     [234]agents.www.media.mit.edu/groups/agents/-MIT Media Lab,
       Autonomous Agents Group
     [235]www.cs.umbc.edu/agents/agentnews/-AgentNews Webletter
     [236]www.cs.umbc.edu/agents-UMBC AgentWeb (includes KQML info) [New]
     [237]www.agent.org-Agent Society Home Page
     [238]www.botspot.com/main.html-The BotSpot (a software agent
       resource page) [New]
     [239]www.cselt.it/fipa/-FIPA Foundation for Intelligent Physical
       Agents
     [240]www.robotmag.com/-Robot Magazine
     [241]www.geocities.com/SiliconValley/3086/robots/index2.htm-Intro to
       Indexing Bots (aka spiders) [New]
       
     [242]luz.cs.nmt.edu/~rtlinux-Real time linux (for robotics, etc)

References

   Visible links:
   1. mailto:jae@ai.uga.edu
   2. http://www.ai.uga.edu/~jae/ai.html
   3. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#What's New
   4. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Intro, Links & Newsgroups
   5. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Purpose
   6. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Finding the Software
   7. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Updates and Comments
   8. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Languages
   9. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Traditional AI
  10. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#AI Libraries
  11. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#AI Applications
  12. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Connectionism
  13. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Conn. Libraries
  14. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Conn. Applications
  15. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Evolutionary Computing
  16. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#EC Libraries
  17. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#EC Applications
  18. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Artificial Life
  19. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Alife Libraries
  20. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Alife Applications
  21. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Agents and Bots
  22. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Newsgroups
  23. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Web Links
  24. http://www.ai.uga.edu/~jae/ai.html
  25. mailto:dheise@metronet.de
  26. http://www-swiss.ai.mit.edu/scheme-home.html
  27. http://www.cat.nyu.edu/fox/schemes.html
  28. http://www.ai.uga.edu/~jae/ai.html
  29. mailto:jae@ai.uga.edu
  30. file://localhost/home/tjbynum/HOWTO/minisrc/AI-Alife.html#Web Links
  31. file://localhost/home/tjbynum/HOWTO/minisrc/mailto=jae@ai.uga.edu
  32. mailto:jae@ai.uga.edu
  33. http://www.di.unipi.it/~attardi/software.html
  34. http://www.cs.bris.ac.uk/~bowers/goedel.html
  35. http://www.isg.sfu.ca/life
  36. ftp://sunsite.unc.edu/pub/Linux/devel/lang/lisp/
  37. http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/clm.html
  38. http://www.mv.com/users/pw/lisp/index.html
  39. ftp://sunsite.unc.edu/pub/Linux/devel/lang/lisp/
  40. ftp://sunsite.unc.edu/pub/Linux/devel/lang/lisp/
  41. http://www.cs.mu.oz.au/research/mercury/
  42. http://www.ps.uni-sb.de/oz/
  43. ftp://ps-ftp.dfki.uni-sb.de/pub/oz2/
  44. http://clement.info.umoncton.ca/BinProlog/UNCOMPRESSED/doc/html/art.html
  45. ftp://clement.info.umoncton.ca/BinProlog/
  46. ftp://clement.info.umoncton.ca/BinProlog/UNCOMPRESSED/bin/
  47. http://swi.psy.uva.nl/projects/xpce/SWI-Prolog.html
  48. ftp://swi.psy.uva.nl/pub/SWI-Prolog/
  49. http://www.neci.nj.nec.com/PLS/Kali.html
  50. http://www.rosette.com/~donovan/rs/rscheme.html
  51. ftp://ftp.rosette.com/pub/rscheme/
  52. http://www-swiss.ai.mit.edu/~jar/s48.html
  53. ftp://swiss-ftp.ai.mit.edu/archive/s48/
  54. http://www-swiss.ai.mit.edu/~jaffer/SCM.html
  55. ftp://swiss-ftp.ai.mit.edu/archive/scm/
  56. http://www.path.berkeley.edu/shift/
  57. ftp://ftp.icce.rug.nl/pub/peter/
  58. mailto:peter@obelix.icce.rug.nl
  59. ftp://chess.onenet.net/pub/chess/uploads/projects/
  60. http://starship.skyport.net/crew/gandalf/DNET/AI/
  61. http://www.cs.cmu.edu/afs/cs.cmu.edu/project/music/web/music.html
  62. http://www.cis.upenn.edu/~screamer-tools/home.html
  63. http://www.ingber.com/#ASA-CODE
  64. ftp://ftp.ingber.com/
  65. ftp://ftp.gmd.de/gmd/ai-research/Software/Babylon/
  66. http://www.coli.uni-sb.de/~clears/
  67. http://www.jsc.nasa.gov/~clips/CLIPS.html
  68. ftp://cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/areas/expert/systems/clips
  69. http://wmwap1.math.uni-wuppertal.de/EMA-XPS/
  70. ftp://ntia.its.bldrdoc.gov/pub/fuzzy/prog/
  71. http://www.dfki.de/lt/registry/generation/fuf.html
  72. ftp://ftp.cs.columbia.edu/pub/fuf/
  73. http://www.cs.kun.nl/agfl/GWB.html
  74. http://www.slip.net/~andrewm/gsm/
  75. http://documents.cfar.umd.edu/resources/source/illuminator.html
  76. http://herzberg.ca.sandia.gov/jess/
  77. http://sunsite.unc.edu/pub/Linux/apps/cai/
  78. http://www.mcs.anl.gov/home/mccune/ar/otter/
  79. http://www.research.att.com/~wcohen/ripperd.html
  80. http://www.cs.buffalo.edu/pub/sneps/WWW/
  81. ftp://ftp.cs.buffalo.edu/pub/sneps/
  82. http://www.isi.edu/soar/soar.html
  83. ftp://cs.cmu.edu/afs/cs/project/soar/public/Soar6/
  84. http://www.cs.vu.nl/~tcm/
  85. ftp://ftp.cs.vu.nl/pub/tcm/
  86. http://lucy.cs.waikato.ac.nz/~ml/
  87. http://www.geocities.com/CapeCanaveral/1624/
  88. http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/reasonng/probabl/belief/0.html
  89. http://www.rpal.rockwell.com/ideal.html
  90. ftp://pink.cs.ucla.edu/pub/
  91. http://iridia.ulb.ac.be/pulcinella/Welcome.html
  92. http://www.spaces.uci.edu/thiery/elimbel/
  93. http://www.cs.utoronto.ca/~radford/fbm.software.html
  94. ftp://ftp.engr.orst.edu/pub/dambrosi/spi/
  95. ftp://ftp.engr.orst.edu/pub/dambrosi/
  96. ftp://iridia.ulb.ac.be/pub/hongxu/software/
  97. http://www.mcs.com/~drt/svbp.html
  98. mailto:drt@mcs.com
  99. http://www.mcs.com/~drt/basisofai.html
 100. ftp://sunsite.unc.edu/pub/academic/computer-science/neural-networks/programs/Aspirin/
 101. http://www.cs.cmu.edu/People/javabayes/index.html/
 102. http://www.bgif.no/neureka/
 103. ftp://ftp.ii.uib.no/pub/neureka/linux/
 104. http://www.cnbc.cmu.edu/PDP++/
 105. ftp://cnbc.cmu.edu/pub/pdp++/
 106. ftp://unix.hensa.ac.uk/mirrors/pdp++/
 107. http://starship.skyport.net/crew/amk/unmaintained/
 108. http://apx00.physik.uni-frankfurt.de/e_ag_rt/cnn/SCNN/homepage.html
 109. http://www-acs.ucsd.edu/~jstrout/python/ai/
 110. http://www.informatik.uni-stuttgart.de/ipvr/bv/projekte/snns/snns.html
 111. ftp://ftp.informatik.uni-stuttgart.de/pub/SNNS/
 112. file://localhost/home/tjbynum/HOWTO/minisrc/SNNS.Readme.linux
 113. http://www.ph.tn.tudelft.nl/~sprlib/
 114. http://www.staff.uiuc.edu/~carroll/ga.html
 115. http://kal-el.ugr.es/gags.html
 116. ftp://kal-el.ugr.es/GAGS/
 117. http://lancet.mit.edu/ga/
 118. ftp://lancet.mit.edu/pub/ga/
 119. http://lancet.mit.edu/ga/Register.html
 120. http://GARAGe.cps.msu.edu/software/software-index.html
 121. ftp://garage.cps.msu.edu/pub/GA/galopps/
 122. http://starship.skyport.net/crew/gandalf/
 123. ftp://ftp.coe.uga.edu/users/jae/ai/
 124. ftp://ftp.aic.nrl.navy.mil/pub/galist/src/
 125. ftp://ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/gp-code/
 126. ftp://cs.ucl.ac.uk/genetic/papers/
 127. http://www.turbopower.com/~kimk/gpjpp.asp
 128. http://www.emk.e-technik.th-darmstadt.de/~thomasw/gp.html
 129. http://isl.msu.edu/GA/software/lil-gp/index.html
 130. ftp://isl.cps.msu.edu/pub/GA/lilgp/
 131. http://www.cs.umd.edu/users/seanl/patched-gp/
 132. http://www.mcs.anl.gov/home/levine/PGAPACK/index.html
 133. ftp://ftp.mcs.anl.gov/pub/pgapack/
 134. http://www.trajan-software.demon.co.uk/sugal.htm
 135. http://www-ia.hiof.no/~rolando/adate_intro.html
 136. http://www.iit.edu/~linjinl/esep.html
 137. http://www.iit.edu/~linjinl/xesep.html
 138. http://pages.prodigy.net/czarneckid/
 139. http://www.cs.ucl.ac.uk/staff/A.Qureshi/gpsys.html
 140. http://alife.santafe.edu/alife/software/jvn.html
 141. ftp://alife.santafe.edu/pub/SOFTWARE/jvn/
 142. http://www.santafe.edu/projects/swarm/
 143. ftp://ftp.santafe.edu/pub/swarm/
 144. ftp://ftp.Germany.EU.net/pub/research/softcomp/Alife/packages/bugsx/
 145. http://www.cs.runet.edu/~dana/ca/cellular.html
 146. ftp://ftp.cc.gatech.edu/ac121/linux/games/amusements/life/
 147. http://pscs.physics.lsa.umich.edu/Software/Drone/
 148. http://parallel.acsu.unsw.edu.au/rks/ecolab.html
 149. http://www.arrakeen.demon.co.uk/downloads.html
 150. ftp://sunsite.unc.edu/pub/Linux/science/ai/life/
 151. http://www-cse.ucsd.edu/users/fil/lee/lee.html
 152. ftp://cs.ucsd.edu/pub/LEE/
 153. http://www.geocities.com/SiliconValley/Heights/1051
 154. ftp://ftp.coe.uga.edu/users/jae/alife/
 155. http://alife.santafe.edu/alife/software/psoup.html
 156. http://www.hip.atr.co.jp/~ray/tierra/tierra.html
 157. ftp://alife.santafe.edu/pub/SOFTWARE/Tierra/
 158. ftp://ftp.cc.gatech.edu/ac121/linux/science/biology/
 159. ftp://ftp.coe.uga.edu/users/jae/alife/
 160. ftp://ftp.cc.gatech.edu/ac121/linux/games/amusements/life/
 161. ftp://ftp.csd.abdn.ac.uk/pub/wdavies/agentk
 162. ftp://ftp.hawk.igs.net/pub/users/jduncan/modules/Agent/
 163. http://www.cs.dartmouth.edu/~agent/
 164. ftp://ftp.cs.dartmouth.edu/pub/agents/
 165. http://www.trl.ibm.co.jp/aglets/
 166. http://www.uni-kl.de/AG-Nehmer/Ara/
 167. http://www.ececs.uc.edu/~abaker/JAFMAS/
 168. http://java.stanford.edu/java_agent/html/
 169. http://cdr.stanford.edu/ABE/JavaAgent.html
 170. http://ptolemy.eecs.berkeley.edu/dgm/javatools/java-to-go/
 171. http://www.fujitsu.co.jp/hypertext/free/kafka/
 172. http://diwww.epfl.ch/lami/team/michel/khep-sim/index.html
 173. http://diwww.epfl.ch/lami/team/michel/
 174. http://www.informatik.uni-stuttgart.de/ipvr/vs/projekte/mole.html
 175. http://www.genmagic.com/agents/
 176. http://www.perl.org/CPAN/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/
 177. http://www.informatik.uni-bremen.de/~simrobot/
 178. ftp://ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/
 179. ftp://ftp.neosoft.com/pub/tcl/sorted/games/tclrobots-2.0/
 180. ftp://ftp.coe.uga.edu/users/jae/ai/tclrobots-redhat.patch
 181. ftp://ftp.redhat.com/contrib/
 182. http://www.cs.uit.no/DOS/Tacoma/index.html
 183. http://www.cs.uit.no/DOS/Virt_Sec/
 184. http://www.ai.uga.edu/~jae/projects.html#vworld
 185. http://www.cs.cmu.edu/~softagents/webmate/
 186. http://www.cis.ohio-state.edu/hypertext/faq/bngusenet/comp/ai/top.html
 187. news:comp.ai
 188. news:comp.ai.edi
 189. news:comp.ai.genetic
 190. news:comp.ai.neural-nets
 191. news:comp.ai.vision
 192. news:comp.ai.fuzzy
 193. news:comp.ai.games
 194. news:comp.ai.jair.announce
 195. news:comp.ai.jair.papers
 196. news:comp.ai.nat-lang
 197. news:comp.ai.nlang-know-rep
 198. news:comp.ai.philosophy
 199. news:comp.ai.shells
 200. news:comp.ai.alife
 201. news:comp.ai.doc-analysis.misc
 202. news:comp.ai.doc-analysis.ocr
 203. news:comp.lang.prolog
 204. news:comp.lang.lisp
 205. news:alt.irc.bots
 206. http://SAL.KachinaTech.COM/Z/3/
 207. http://www.cs.cmu.edu/Web/Groups/AI/html/repository.html
 208. http://liinwww.ira.uka.de/bibliography/Ai/index.html
 209. http://www.mcs.net/~jorn/html/ai.html
 210. http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/clm.html
 211. http://www.elwoodcorp.com/alu/table/contents.htm
 212. http://www.cs.indiana.edu/scheme-repository/home.html
 213. http://www.aic.nrl.navy.mil/
 214. http://intranet.ca/~sshah/waste/waste.html
 215. http://www.cs.washington.edu/research/jair/home.html
 216. http://www.cs.ucl.ac.uk/misc/ai/
 217. http://www.cris.com/~swoodcoc/ai.html
 218. http://strips.lboro.ac.uk/bib/
 219. http://www.neuronet.ph.kcl.ac.uk/neuronet/software/software.html
 220. ftp://ftp.mad-scientist.com/pub/genetic-programming/
 221. http://www.cpsc.ucalgary.ca/~jacob/Evolvica/
 222. http://alife.santafe.edu/~joke/encore/
 223. http://gal4.ge.uiuc.edu/illigal.home.html
 224. http://isl.msu.edu/GA/
 225. http://www.aracnet.com/~wwir/NovaGenetica/
 226. http://alife.santafe.edu/~joke/zooland/
 227. http://alife.santafe.edu/
 228. http://www.krl.caltech.edu/~brown/alife/
 229. http://www.cogs.susx.ac.uk/users/ezequiel/alife-page/alife.html
 230. http://complex.csu.edu.au/complex/
 231. http://www.geneticprogramming.com/
 232. http://gracco.irmkant.rm.cnr.it/luigi/lupa_algames.html
 233. http://www.krl.caltech.edu/~charles/alife-game/
 234. http://agents.www.media.mit.edu/groups/agents/
 235. http://www.cs.umbc.edu/agents/agentnews/
 236. http://www.cs.umbc.edu/agents/
 237. http://www.agent.org/
 238. http://www.botspot.com/main.html
 239. http://www.cselt.it/fipa/
 240. http://www.robotmag.com/
 241. http://www.geocities.com/SiliconValley/3086/robots/index2.htm
 242. http://luz.cs.nmt.edu/~rtlinux/

   Hidden links:
 243. http://www.cs.nyu.edu/~klap7794/spiderweb2.html
